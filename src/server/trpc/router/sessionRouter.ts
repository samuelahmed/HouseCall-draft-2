import { router, publicProcedure, privateProcedure } from "../trpc";
import { z } from "zod";
import slug from "slug";

export const sessionRouter = router({
  createOneSession: privateProcedure
    .input(
      z.object({
        name: z.string(),
        address: z.string(),
        medicalNotes: z.string(),
        overview: z.string(),
        title: z.string(),
        hourlyRate: z.number(),
        totalHours: z.number(),
        totalCompensation: z.number(),
        acceptedCaregiverId: z.string(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const {
        acceptedCaregiverId,
        name,
        address,
        medicalNotes,
        overview,
        title,
        hourlyRate,
        totalHours,
        totalCompensation,
      } = input;
      //Instead of generating random string here it would be better to just use the id generated by prisma when the session is created
      const sessionId = Math.random().toString(36).substring(7);
      const user = await ctx.prisma.user.findUnique({
        where: {
          id: ctx.session.user.id,
        },
      });
      if (!user) {
        throw new Error("Meow! user not found.");
      }
      const userId = user.id;
      const item = await ctx.prisma.careSession.create({
        data: {
          sessionId,
          name,
          address,
          medicalNotes,
          overview,
          title,
          hourlyRate,
          totalHours,
          totalCompensation,
          acceptedCaregiverId,
          slug: slug(sessionId),
          authorId: userId,
        },
      });
      return item;
    }),

  getAllSessions: publicProcedure.query(({ ctx }) => {
    const items = ctx.prisma.careSession.findMany({
      include: {
        author: {
          select: {
            id: true,
            username: true,
            role: true,
          },
        },
      },
    });
    return items;
  }),

  getAllSessionsByUser: privateProcedure.query(({ ctx }) => {
    if (!ctx.session || !ctx.session.user) {
      return null;
    }
    const items = ctx.prisma.careSession.findMany({
      where: {
        authorId: ctx.session.user.id,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            role: true,
          },
        },
      },
    });
    return items;
  }),

  getOneSession: privateProcedure
    .input(z.object({ slug: z.string() }))
    .query(async ({ ctx, input }) => {
      const { slug } = input;
      const card = await ctx.prisma.careSession.findUnique({
        where: {
          slug,
        },
      });
      return card;
    }),

  getOneSessionTwo: privateProcedure
    .input(z.object({ sessionId: z.string() }))
    .query(async ({ ctx, input }) => {
      const { sessionId } = input;
      const returnedSession = ctx.prisma.careSession.findUnique({
        where: {
          sessionId,
        },
      });
      return returnedSession;
    }),

  addOnePotentialCaregiver: privateProcedure
    .input(
      z.object({
        careSessionId: z.string(),
        userId: z.string(),
        status: z.string(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const { careSessionId, userId, status } = input;
      const item = await ctx.prisma.potentialCaregiver.create({
        data: {
          careSessionId,
          userId,
          status,
        },
      });
      return item;
    }),
});
